{-
    BNF Converter: Layout handling Generator
    Copyright (C) 2004  Author:  Aarne Ranta
    Copyright (C) 2005  Bjorn Bringert

-}

module BNFC.Backend.Haskell.CFtoLayout where

import Data.List                  ( sort )
import Data.Maybe                 ( fromMaybe )

import BNFC.CF
import BNFC.Options               ( TokenText )
import BNFC.PrettyPrint
import BNFC.Utils                 ( table )
import BNFC.Backend.Haskell.Utils ( tokenTextImport, tokenTextPackParens, tokenTextUnpack )

layoutOpen  = "{"
layoutClose = "}"
layoutSep   = ";"

cf2Layout :: TokenText -> String -> String -> CF -> String
cf2Layout tokenText layName lexName cf = unlines $ concat
  [ [ "-- Generated by the BNF Converter"
    , ""
    , "{-# LANGUAGE LambdaCase #-}"
    , "{-# LANGUAGE PatternGuards #-}"
    , "{-# LANGUAGE OverloadedStrings #-}"
    , ""
    , "module " ++ layName ++ " where"
    , ""
    , "import Prelude"
    , "import Data.Maybe ( fromMaybe, listToMaybe )"
    , ""
    , "import " ++ lexName
    , "  ( Posn(..), Tok(..), Token(..), TokSymbol(..)"
    , "  , prToken, tokenLineCol, tokenPosn"
    , "  )"
    , ""
    , "-- local parameters"
    , ""
    , "topLayout :: Bool"
    , "topLayout = " ++ show top
    , ""
    , "layoutWords, layoutStopWords :: [TokSymbol]"
    , render $ prettyList 2 "layoutWords     =" "[" "]" "," $ map (text . show) lay
    , render $ prettyList 2 "layoutStopWords =" "[" "]" "," $ map (text . show) stop
    , ""
    , "-- layout separators"
    , ""
    , "layoutOpen, layoutClose, layoutSep :: TokSymbol"
    , "layoutOpen  = " ++ show (mkTokSymbol layoutOpen)
    , "layoutClose = " ++ show (mkTokSymbol layoutClose)
    , "layoutSep   = " ++ show (mkTokSymbol layoutSep)
    , ""
    , "-- | Replace layout syntax with explicit layout tokens."
    , "resolveLayout :: Bool    -- ^ Whether to use top-level layout."
    , "              -> [Token] -> [Token]"
    , "resolveLayout tp = res Nothing [if tl then Implicit Definitive 1 else Explicit]"
    , "  where"
    , "  -- Do top-level layout if the function parameter and the grammar say so."
    , "  tl = tp && topLayout"
    , ""
    , "  res :: Maybe Token -- ^ The previous token, if any."
    , "      -> [Block]     -- ^ A stack of layout blocks."
    , "      -> [Token] -> [Token]"
    , ""
    , "  -- The stack should never be empty."
    , "  res _ [] ts = error $ \"Layout error: stack empty. Tokens: \" ++ show ts"
    , ""
    , "  -- Handling explicit blocks:"
    , "  res _ st (t0 : ts)"
    , "    -- We found an open brace in the input,"
    , "    -- put an explicit layout block on the stack."
    , "    -- This is done even if there was no layout word,"
    , "    -- to keep opening and closing braces."
    , "    | isLayoutOpen t0 = t0 : res (Just t0) (Explicit : st) ts"
    , ""
    , "    -- If we encounter a closing brace, exit the first explicit layout block."
    , "    | isLayoutClose t0 ="
    , "          let (imps, rest) = span isImplicit st"
    , "              st' = drop 1 rest"
    , "           in if null st'"
    , "                 then error $ \"Layout error: Found \" ++ show (tsText layoutClose) ++ \" at (\""
    , "                              ++ show (line t0) ++ \",\" ++ show (column t0)"
    , "                              ++ \") without an explicit layout block.\""
    , "                 else map (const t0) imps ++ t0 : res (Just t0) st' ts"
    , ""
    , "  -- Ending or confirming implicit layout blocks:"
    , "  res pt (Implicit status n : ns) (t0 : ts)"
    , ""
    , "      -- End of implicit block by a layout stop word"
    , "    | isStop t0 ="
    , "           -- Exit the current block and all implicit blocks"
    , "           -- more indented than the current token."
    , "       let (ebs, ns') = span ((column t0 <) . indentation) ns"
    , "           -- The number of blocks exited:"
    , "           k  = 1 + length ebs"
    , "           -- Insert closing braces after the previous token."
    , "           bs = replicate k $ sToken (afterPrev pt) layoutClose"
    , "        in bs ++ t0 : res (Just t0) ns' ts"
    , ""
    , "    -- End of an implicit layout block"
    , "    | newLine pt t0 && column t0 < n  ="
    , "           -- Insert a closing brace after the previous token."
    , "           -- Repeat, with the current block removed from the stack."
    , "       let b = sToken (afterPrev pt) layoutClose"
    , "       in  b : res (Just b) ns (t0 : ts)"
    , ""
    , "    -- If we are on a newline, confirm the last tentative blocks."
    , "    | newLine pt t0, Tentative{} <- status ="
    , "           res pt (Implicit Definitive n : confirm n ns) (t0 : ts)"
    , ""
    , "  -- Starting and processing implicit layout blocks:"
    , "  res pt st (t0 : ts)"
    , "    -- Start a new layout block if the first token is a layout word."
    , "    | isLayout t0 = maybeInsertSeparator pt t0 st $"
    , "        case ts of"
    , "          -- Explicit layout, just move on. The next step"
    , "          -- will push an explicit layout block."
    , "          t1 : _ | isLayoutOpen t1 ->"
    , "            t0 : res (Just t0) st ts"
    , "          -- Otherwise, insert an open brace after the layout word"
    , "          _ ->"
    , "            t0 : b : res (Just b) (addImplicit (tokenPosn t0) pos st) ts"
    , "            where"
    , "            b   = sToken (nextPos t0) layoutOpen"
    , "            -- At the end of the file, the start column does not matter."
    , "            -- So if there is no token t1 after t0, just use the position of t0."
    , "            pos = tokenPosn $ fromMaybe t0 $ listToMaybe ts"
    , ""
    , "    -- Insert separator if necessary."
    , "    | otherwise = maybeInsertSeparator pt t0 st $"
    , "        t0 : res (Just t0) st ts"
    , ""
    , "  -- At EOF: skip explicit blocks."
    , "  res (Just _) [Explicit]      [] = []"
    , "  res (Just t) (Explicit : bs) [] = res (Just t) bs []"
    , ""
    , "  -- If we are using top-level layout, insert a semicolon after"
    , "  -- the last token, if there isn't one already"
    , "  res (Just t) [Implicit{}] []"
    , "      | isLayoutSep t = []"
    , "      | otherwise     = [sToken (nextPos t) layoutSep]"
    , ""
    , "  -- At EOF in an implicit, non-top-level block: close the block"
    , "  res (Just t) (Implicit{} : bs) [] = b : res (Just b) bs []"
    , "      where b = sToken (nextPos t) layoutClose"
    , ""
    , "  -- This should only happen if the input is empty."
    , "  res Nothing _st [] = []"
    , ""
    , "  -- | Insert a 'layoutSep' if we are on a new line on the current"
    , "  --   implicit layout column."
    , "  maybeInsertSeparator"
    , "    :: Maybe Token  -- ^ The previous token."
    , "    -> Token        -- ^ The current token."
    , "    -> [Block]      -- ^ The layout stack."
    , "    -> [Token]      -- ^ The result token stream."
    , "    -> [Token]      -- ^ Maybe prepended with a 'layoutSep'."
    , "  maybeInsertSeparator pt t0 = \\case"
    , "    Implicit _ n : _"
    , "      | newLine pt t0"
    , "      , column t0 == n"
    , "      , maybe False (not . isTokenIn [layoutSep, layoutOpen]) pt ->"
    , "       -- Insert a semicolon after the previous token"
    , "       -- unless we are the beginning of the file,"
    , "       -- or the previous token is a semicolon or open brace."
    , "         (sToken (afterPrev pt) layoutSep :)"
    , "    _ -> id"
    , ""
    , "type Position = Posn"
    , "type Line     = Int"
    , "type Column   = Int"
    , ""
    , "-- | Entry of the layout stack."
    , "data Block"
    , "   = Implicit Status Column -- ^ An implicit layout block with its start column."
    , "   | Explicit"
    , ""
    , "-- | Get current indentation.  0 if we are in an explicit block."
    , "indentation :: Block -> Column"
    , "indentation (Implicit _ n) = n"
    , "indentation Explicit       = 0"
    , ""
    , "-- | Check if s block is implicit."
    , "isImplicit :: Block -> Bool"
    , "isImplicit Implicit{} = True"
    , "isImplicit Explicit   = False"
    , ""
    , "data Status"
    , "  = Tentative   -- ^ A layout column that has not been confirmed by a line break"
    , "  | Definitive  -- ^ A layout column that has been confirmed by a line break."
    , ""
    , "-- | Add a new implicit layout block."
    , "addImplicit"
    , "  :: Position  -- ^ Position of the layout keyword."
    , "  -> Position  -- ^ Position of the token following the layout keword."
    , "  -> [Block]"
    , "  -> [Block]"
    , "addImplicit (Pn _ l0 _) (Pn _ l1 c1) st"
    , "    -- Case: layout keyword was at the end of the line:"
    , "    -- New implicit block is definitive."
    , "    | l1 > l0   = Implicit Definitive (col st') : st'"
    , "    -- Case: staying on the same line:"
    , "    -- New implicit block is tentative."
    , "    | otherwise = Implicit Tentative (col st) : st"
    , "  where"
    , "  st' = confirm c1 st"
    , "  col bs = max c1 $ 1 + definiteIndentation bs"
    , "    -- The column of the next token determines the starting column"
    , "    -- of the implicit layout block."
    , "    -- However, the next block needs to be strictly more indented"
    , "    -- than the previous block."
    , ""
    , "  -- | Get the current confirmed indentation level."
    , "  definiteIndentation :: [Block] -> Int"
    , "  definiteIndentation bs ="
    , "    case dropWhile isTentative bs of"
    , "      Implicit Definitive n : _ -> n"
    , "      _ -> 0  -- 0 enables a first unindented block, see 194_layout/good05.in"
    , ""
    , "  isTentative :: Block -> Bool"
    , "  isTentative = \\case"
    , "    Implicit Tentative _ -> True"
    , "    _ -> False"
    , ""
    , "-- | Confirm tentative blocks that are not more indented than @col@."
    , "confirm :: Column -> [Block] -> [Block]"
    , "confirm c0 = loop"
    , "  where"
    , "  loop = \\case"
    , "    Implicit Tentative c : bs"
    , "      | c <= c0 -> Implicit Definitive c : loop bs"
    , "    bs -> bs"
    , ""
    , "-- | Get the position immediately to the right of the given token."
    , "--   If no token is given, gets the first position in the file."
    , "afterPrev :: Maybe Token -> Position"
    , "afterPrev = maybe (Pn 0 1 1) nextPos"
    , ""
    , "-- | Get the position immediately to the right of the given token."
    , "nextPos :: Token -> Position"
    , "nextPos t = Pn (g + s) l (c + s + 1)"
    , "  where"
    , "  Pn g l c = tokenPosn t"
    , "  s        = tokenLength t"
    , ""
    , "-- | Get the number of characters in the token."
    , "tokenLength :: Token -> Int"
    , "tokenLength = length . prToken"
    , ""
    , "-- | Create a position symbol token."
    , "sToken :: Position -> TokSymbol -> Token"
    , "sToken p t = PT p $ TK t"
    , ""
    , "-- | Get the line number of a token."
    , "line :: Token -> Line"
    , "line = fst . tokenLineCol"
    , ""
    , "-- | Get the column number of a token."
    , "column :: Token -> Column"
    , "column = snd . tokenLineCol"
    , ""
    , "-- | Is the following token on a new line?"
    , "newLine :: Maybe Token -> Token -> Bool"
    , "newLine pt t0 = maybe True ((line t0 >) . line) pt"
    , ""
    , "-- | Check if a token is one of the given symbols."
    , "isTokenIn :: [TokSymbol] -> Token -> Bool"
    , "isTokenIn ts = \\case"
    , "  PT _ (TK t) -> t `elem` ts"
    , "  _ -> False"
    , ""
    , "-- | Check if a word is a layout start token."
    , "isLayout :: Token -> Bool"
    , "isLayout = isTokenIn layoutWords"
    , ""
    , "-- | Check if a token is a layout stop token."
    , "isStop :: Token -> Bool"
    , "isStop = isTokenIn layoutStopWords"
    , ""
    , "-- | Check if a token is the layout open token."
    , "isLayoutOpen :: Token -> Bool"
    , "isLayoutOpen = isTokenIn [layoutOpen]"
    , ""
    , "-- | Check if a token is the layout separator token."
    , "isLayoutSep :: Token -> Bool"
    , "isLayoutSep = isTokenIn [layoutSep]"
    , ""
    , "-- | Check if a token is the layout close token."
    , "isLayoutClose :: Token -> Bool"
    , "isLayoutClose = isTokenIn [layoutClose]"
    ]
  ]
  where
  (top, lay0, stop0) = layoutPragmas cf
  lay  = map mkTokSymbol lay0
  stop = map mkTokSymbol stop0
  mkTokSymbol :: String -> TokSymbol
  mkTokSymbol x = TokSymbol x n
    where
    n = fromMaybe undefined $ lookup x tokens
  tokens = cfTokens cf

data TokSymbol = TokSymbol String Int
  deriving Show
