{-
    BNF Converter: Layout handling Generator
    Copyright (C) 2004  Author:  Aarne Ranta
    Copyright (C) 2005  Bjorn Bringert

-}

module BNFC.Backend.Haskell.CFtoLayout where

import Data.List                  ( sort )
import Data.Maybe                 ( fromMaybe )

import BNFC.CF
import BNFC.Options               ( TokenText )
import BNFC.PrettyPrint
import BNFC.Utils                 ( table )
import BNFC.Backend.Haskell.Utils ( tokenTextImport, tokenTextPackParens, tokenTextUnpack )

layoutOpen  = "{"
layoutClose = "}"
layoutSep   = ";"

cf2Layout :: TokenText -> String -> String -> CF -> String
cf2Layout tokenText layName lexName cf = unlines $ concat
  [ [ "-- Generated by the BNF Converter"
    , ""
    , "{-# LANGUAGE LambdaCase #-}"
    , "{-# LANGUAGE PatternSynonyms #-}"
    , "{-# LANGUAGE OverloadedStrings #-}"
    , ""
    , "module " ++ layName ++ " where"
    , ""
    , "import Prelude"
    , ""
    , "import " ++ lexName
    , "  ( Posn(..), Tok(..), Token(..), TokSymbol(..)"
    , "  , prToken, tokenLineCol, tokenPosn"
    , "  )"
    , ""
    , "-- local parameters"
    , ""
    , "topLayout :: Bool"
    , "topLayout = " ++ show top
    , ""
    , "layoutWords, layoutStopWords :: [TokSymbol]"
    , render $ prettyList 2 "layoutWords     =" "[" "]" "," $ map (text . show) lay
    , render $ prettyList 2 "layoutStopWords =" "[" "]" "," $ map (text . show) stop
    , ""
    , "-- layout separators"
    , ""
    , "layoutOpen, layoutClose, layoutSep :: TokSymbol"
    , "layoutOpen  = " ++ show (mkTokSymbol layoutOpen)
    , "layoutClose = " ++ show (mkTokSymbol layoutClose)
    , "layoutSep   = " ++ show (mkTokSymbol layoutSep)
    , ""
    , "-- | Replace layout syntax with explicit layout tokens."
    , "resolveLayout :: Bool    -- ^ Whether to use top-level layout."
    , "              -> [Token] -> [Token]"
    , "resolveLayout tp = res Nothing [if tl then Implicit 1 else Explicit]"
    , "  where"
    , "  -- Do top-level layout if the function parameter and the grammar say so."
    , "  tl = tp && topLayout"
    , ""
    , "  res :: Maybe Token -- ^ The previous token, if any."
    , "      -> [Block]     -- ^ A stack of layout blocks."
    , "      -> [Token] -> [Token]"
    , ""
    , "  -- The stack should never be empty."
    , "  res _ [] ts = error $ \"Layout error: stack empty. Tokens: \" ++ show ts"
    , ""
    , "  res _ st (t0 : ts)"
    , "    -- We found an open brace in the input,"
    , "    -- put an explicit layout block on the stack."
    , "    -- This is done even if there was no layout word,"
    , "    -- to keep opening and closing braces."
    , "    | isLayoutOpen t0 = t0 : res (Just t0) (Explicit : st) ts"
    , ""
    , "  -- We are in an implicit layout block"
    , "  res pt (Implicit n : ns) (t0 : ts)"
    , ""
    , "      -- End of implicit block by a layout stop word"
    , "    | isStop t0 ="
    , "           -- Exit the current block and all implicit blocks"
    , "           -- more indented than the current token."
    , "       let (ebs, ns') = span ((column t0 <) . indentation) ns"
    , "           -- The number of blocks exited:"
    , "           k  = 1 + length ebs"
    , "           -- Insert closing braces after the previous token."
    , "           bs = replicate k $ sToken (afterPrev pt) layoutClose"
    , "        in bs ++ t0 : res (Just t0) ns' ts"
    , ""
    , "    -- End of an implicit layout block"
    , "    | newLine pt t0 && column t0 < n  ="
    , "           -- Insert a closing brace after the previous token."
    , "           -- Repeat, with the current block removed from the stack."
    , "       let b = sToken (afterPrev pt) layoutClose"
    , "       in  b : res (Just b) ns (t0 : ts)"
    , ""
    , "  res pt st (t0 : ts)"
    , "    -- Start a new layout block if the first token is a layout word"
    , "    | isLayout t0 ="
    , "        case ts of"
    , "            -- Explicit layout, just move on. The case above"
    , "            -- will push an explicit layout block."
    , "            t1 : _ | isLayoutOpen t1 -> t0 : res (Just t0) st ts"
    , "                 -- The column of the next token determines the starting column"
    , "                 -- of the implicit layout block."
    , "                 -- However, the next block needs to be strictly more indented"
    , "                 -- than the previous block."
    , "            _ -> let col = max (indentation (head st) + 1) $"
    , "                       -- at end of file, the start column doesn't matter"
    , "                       if null ts then column t0 else column (head ts)"
    , "                     -- insert an open brace after the layout word"
    , "                     b   = sToken (nextPos t0) layoutOpen"
    , "                     -- save the start column"
    , "                     st' = Implicit col : st"
    , "                     ctd = t0 : b : res (Just b) st' ts"
    , "                 in -- Do we have to insert an extra layoutSep?"
    , "                case st of"
    , "                  Implicit n : _"
    , "                    | newLine pt t0 && column t0 == n"
    , "                      && maybe False (not . isTokenIn [layoutSep, layoutOpen]) pt ->"
    , "                       sToken (afterPrev pt) layoutSep : ctd"
    , "                  _ -> ctd"
    , ""
    , "    -- If we encounter a closing brace, exit the first explicit layout block."
    , "    | isLayoutClose t0 ="
    , "          let (imps, rest) = span isImplicit st"
    , "              st' = drop 1 rest"
    , "           in if null st'"
    , "                 then error $ \"Layout error: Found \" ++ show (tsText layoutClose) ++ \" at (\""
    , "                              ++ show (line t0) ++ \",\" ++ show (column t0)"
    , "                              ++ \") without an explicit layout block.\""
    , "                 else map (const t0) imps ++ t0 : res (Just t0) st' ts"
    , ""
    , "  -- Insert separator if necessary."
    , "  res pt st@(Implicit n : _) (t0 : ts)"
    , "    -- Encountered a new line in an implicit layout block."
    , "    | newLine pt t0 && column t0 == n ="
    , "       -- Insert a semicolon after the previous token"
    , "       -- unless we are the beginning of the file,"
    , "       -- or the previous token is a semicolon or open brace."
    , "       if maybe True (isTokenIn [layoutSep, layoutOpen]) pt"
    , "          then ctd"
    , "          else sToken (afterPrev pt) layoutSep : ctd"
    , "       where"
    , "       ctd = t0 : res (Just t0) st ts"
    , ""
    , "  -- Nothing to see here, move along."
    , "  res _ st (t : ts)  = t : res (Just t) st ts"
    , ""
    , "  -- At EOF: skip explicit blocks."
    , "  res (Just _) [Explicit]      [] = []"
    , "  res (Just t) (Explicit : bs) [] = res (Just t) bs []"
    , ""
    , "  -- If we are using top-level layout, insert a semicolon after"
    , "  -- the last token, if there isn't one already"
    , "  res (Just t) [Implicit _n] []"
    , "      | isLayoutSep t = []"
    , "      | otherwise     = [sToken (nextPos t) layoutSep]"
    , ""
    , "  -- At EOF in an implicit, non-top-level block: close the block"
    , "  res (Just t) (Implicit _ : bs) [] = b : res (Just b) bs []"
    , "      where b = sToken (nextPos t) layoutClose"
    , ""
    , "  -- This should only happen if the input is empty."
    , "  res Nothing _st [] = []"
    , ""
    , "data Block"
    , "   = Implicit Int -- ^ An implicit layout block with its start column."
    , "   | Explicit"
    , "   deriving Show"
    , ""
    , "-- | Get current indentation.  0 if we are in an explicit block."
    , "indentation :: Block -> Int"
    , "indentation (Implicit n) = n"
    , "indentation Explicit     = 0"
    , ""
    , "-- | Check if s block is implicit."
    , "isImplicit :: Block -> Bool"
    , "isImplicit (Implicit _) = True"
    , "isImplicit Explicit     = False"
    , ""
    , "type Position = Posn"
    , ""
    , "-- | Get the position immediately to the right of the given token."
    , "--   If no token is given, gets the first position in the file."
    , "afterPrev :: Maybe Token -> Position"
    , "afterPrev = maybe (Pn 0 1 1) nextPos"
    , ""
    , "-- | Get the position immediately to the right of the given token."
    , "nextPos :: Token -> Position"
    , "nextPos t = Pn (g + s) l (c + s + 1)"
    , "  where"
    , "  Pn g l c = tokenPosn t"
    , "  s        = tokenLength t"
    , ""
    , "-- | Get the number of characters in the token."
    , "tokenLength :: Token -> Int"
    , "tokenLength = length . prToken"
    , ""
    , "-- | Create a position symbol token."
    , "sToken :: Position -> TokSymbol -> Token"
    , "sToken p t = PT p $ TK t"
    , ""
    , "-- | Get the line number of a token."
    , "line :: Token -> Int"
    , "line = fst . tokenLineCol"
    , ""
    , "-- | Get the column number of a token."
    , "column :: Token -> Int"
    , "column = snd . tokenLineCol"
    , ""
    , "-- | Is the following token on a new line?"
    , "newLine :: Maybe Token -> Token -> Bool"
    , "newLine pt t0 = maybe True ((line t0 >) . line) pt"
    , ""
    , "-- | Check if a token is one of the given symbols."
    , "isTokenIn :: [TokSymbol] -> Token -> Bool"
    , "isTokenIn ts = \\case"
    , "  PT _ (TK t) -> t `elem` ts"
    , "  _ -> False"
    , ""
    , "-- | Check if a word is a layout start token."
    , "isLayout :: Token -> Bool"
    , "isLayout = isTokenIn layoutWords"
    , ""
    , "-- | Check if a token is a layout stop token."
    , "isStop :: Token -> Bool"
    , "isStop = isTokenIn layoutStopWords"
    , ""
    , "-- | Check if a token is the layout open token."
    , "isLayoutOpen :: Token -> Bool"
    , "isLayoutOpen = isTokenIn [layoutOpen]"
    , ""
    , "-- | Check if a token is the layout separator token."
    , "isLayoutSep :: Token -> Bool"
    , "isLayoutSep = isTokenIn [layoutSep]"
    , ""
    , "-- | Check if a token is the layout close token."
    , "isLayoutClose :: Token -> Bool"
    , "isLayoutClose = isTokenIn [layoutClose]"
    ]
  ]
  where
  (top, lay0, stop0) = layoutPragmas cf
  lay  = map mkTokSymbol lay0
  stop = map mkTokSymbol stop0
  mkTokSymbol :: String -> TokSymbol
  mkTokSymbol x = TokSymbol x n
    where
    n = fromMaybe undefined $ lookup x tokens
  tokens = cfTokens cf

data TokSymbol = TokSymbol String Int
  deriving Show
